{
  "language": "Solidity",
  "sources": {
    "contracts/tests/xBitsToken_Test.sol": {
      "content": "// Adds Test library to the context\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\npragma solidity ^0.8.6;\n\n// `_Test` suffix means it is a test contract\ncontract xBitsToken_Test {\n\n  receive() external payable {} // necessary to receive eth from test runner\n\n  // `_test` suffix means it is a test function\n  function addition_test() public {\n    prepare();\n    // Logging will be interpreted by hardhat-test-solidity\n    Test.eq(4,2+2,\"oh no\");\n  }\n\n  // Will not be interpreted as a test function\n  function prepare() public {}\n}"
    },
    "@mangrovedao/hardhat-test-solidity/test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n// Should be kept in sync with ./lib.js\n\nlibrary Test {\n  /* \n   * Expect events from contracts\n   */\n  event ExpectFrom(address from);\n  event StopExpecting();\n\n  // Usage: from a test contract `t`, call `expectFrom(a)`. \n  // Any subsequent non-special event emitted by `t` will mean \n  // \"I expect `a` to emit the exact same event\". \n  // The order of expectations must be respected.\n  function expectFrom(address from) internal {\n    emit ExpectFrom(from);\n  }\n\n  // After using `expectFrom` and emitting some events you expect\n  // to see emitted elsewhere, you can use `stopExpecting` to emit \n  // further, normal events from your test.\n  function stopExpecting() internal {\n    emit StopExpecting();\n  }\n\n\n  /* \n   * Boolean test\n   */\n  event TestTrue(bool success, string message);\n\n  // Succeed iff success is true\n  function check(bool success, string memory message) internal {\n    emit TestTrue(success, message);\n  }\n\n\n  /* \n   * Always fail, always succeed\n   */\n  function fail(string memory message) internal {\n    emit TestTrue(false, message);\n  }\n\n  function succeed() internal {\n    emit TestTrue(true, \"Success\");\n  }\n\n  /* \n   * Equality testing\n   * ! overloaded as `eq` for everything except for bytes use `eq0`.\n   */\n\n  // Bytes\n  event TestEqBytes(bool success, bytes actual, bytes expected, string message);\n\n  function eq0(\n    bytes memory actual,\n    bytes memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256((actual)) == keccak256((expected));\n    emit TestEqBytes(success, actual, expected, message);\n    return success;\n  }\n\n   // Byte32\n  event TestEqBytes32(\n    bool success,\n    bytes32 actual,\n    bytes32 expected,\n    string message\n  );\n\n  function eq(\n    bytes32 actual,\n    bytes32 expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBytes32(success, actual, expected, message);\n    return success;\n  }\n\n  // Bool\n  event TestEqBool(bool success, bool actual, bool expected, string message);\n  function eq(\n    bool actual,\n    bool expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBool(success, actual, expected, message);\n    return success;\n  }\n\n  // uints\n  event TestEqUint(bool success, uint actual, uint expected, string message);\n\n  function eq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqUint(success, actual, expected, message);\n    return success;\n  }\n\n  // strings\n  event TestEqString(\n    bool success,\n    string actual,\n    string expected,\n    string message\n  );\n\n  function eq(\n    string memory actual,\n    string memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256(bytes((actual))) == keccak256(bytes((expected)));\n    emit TestEqString(success, actual, expected, message);\n    return success;\n  }\n\n  // addresses\n  event TestEqAddress(\n    bool success,\n    address actual,\n    address expected,\n    string message\n  );\n\n\n  function eq(\n    address actual,\n    address expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqAddress(success, actual, expected, message);\n    return success;\n  }\n\n  /* \n   * Inequality testing\n   */\n  event TestLess(bool success, uint actual, uint expected, string message);\n  function less(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual < expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n\n  event TestLessEq(bool success, uint actual, uint expected, string message);\n  function lessEq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual <= expected;\n    emit TestLessEq(success, actual, expected, message);\n    return success;\n  }\n\n  event TestMore(bool success, uint actual, uint expected, string message);\n  function more(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual > expected;\n    emit TestMore(success, actual, expected, message);\n    return success;\n  }\n\n  event TestMoreEq(bool success, uint actual, uint expected, string message);\n  function moreEq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual >= expected;\n    emit TestMoreEq(success, actual, expected, message);\n    return success;\n  }\n}\n\n// /* Either cast your arguments to address when you call balanceOf logging functions\n//    or add `is address` to your ERC20s\n//    or use the overloads with `address` types */\ninterface ERC20BalanceOf {\n  function balanceOf(address account) view external returns (uint);\n}\n\n\nlibrary Display {\n  /* ****************************************************************\n   * Register/read address->name mappings to make logs easier to read.\n   *****************************************************************/\n  /* \n   * Names are stored in the contract using the library.\n   */\n\n  // Disgusting hack so a library can manipulate storage refs.\n  bytes32 constant NAMES_POS = keccak256(\"Display.NAMES_POS\");\n  // Store mapping in library caller's storage.\n  // That's quite fragile.\n  struct Registers {\n    mapping(address => string) map;\n  }\n\n  // Also send mapping to javascript test interpreter.  The interpreter COULD\n  // just make an EVM call to map every name but that would probably be very\n  // slow.  So we cache locally.\n  event Register(address addr, string name);\n\n  function registers() internal view returns (Registers storage) {\n    this; // silence warning about pure mutability\n    Registers storage regs;\n    bytes32 _slot = NAMES_POS;\n    assembly {\n      regs.slot := _slot\n    }\n    return regs;\n  }\n\n  /*\n   * Give a name to an address for logging purposes\n   * @example\n   * ```solidity\n   * address addr = address(new Contract());\n   * register(addr,\"My Contract instance\");\n   * ```\n   */\n\n  function register(address addr, string memory name) internal {\n    registers().map[addr] = name;\n    emit Register(addr, name);\n  }\n\n  /*\n   * Read the name of a registered address. Default: \"<not found>\". \n   */\n  function nameOf(address addr) internal view returns (string memory) {\n    string memory s = registers().map[addr];\n    if (keccak256(bytes(s)) != keccak256(bytes(\"\"))) {\n      return s;\n    } else {\n      return \"<not found>\";\n    }\n  }\n\n  /* 1 arg logging (string/uint) */\n\n  event LogString(string a);\n\n  function log(string memory a) internal {\n    emit LogString(a);\n  }\n\n  event LogUint(uint a);\n\n  function log(uint a) internal {\n    emit LogUint(a);\n  }\n\n  /* 2 arg logging (string/uint) */\n\n  event LogStringString(string a, string b);\n\n  function log(string memory a, string memory b) internal {\n    emit LogStringString(a, b);\n  }\n\n  event LogStringUint(string a, uint b);\n\n  function log(string memory a, uint b) internal {\n    emit LogStringUint(a, b);\n  }\n\n  event LogUintUint(uint a, uint b);\n\n  function log(uint a, uint b) internal {\n    emit LogUintUint(a, b);\n  }\n\n  event LogUintString(uint a, string b);\n\n  function log(uint a, string memory b) internal {\n    emit LogUintString(a, b);\n  }\n\n  /* 3 arg logging (string/uint) */\n\n  event LogStringStringString(string a, string b, string c);\n\n  function log(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogStringStringString(a, b, c);\n  }\n\n  event LogStringStringUint(string a, string b, uint c);\n\n  function log(\n    string memory a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogStringStringUint(a, b, c);\n  }\n\n  event LogStringUintUint(string a, uint b, uint c);\n\n  function log(\n    string memory a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogStringUintUint(a, b, c);\n  }\n\n  event LogStringUintString(string a, uint b, string c);\n\n  function log(\n    string memory a,\n    uint b,\n    string memory c\n  ) internal {\n    emit LogStringUintString(a, b, c);\n  }\n\n  event LogUintUintUint(uint a, uint b, uint c);\n\n  function log(\n    uint a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogUintUintUint(a, b, c);\n  }\n\n  event LogUintStringUint(uint a, string b, uint c);\n\n  function log(\n    uint a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogUintStringUint(a, b, c);\n  }\n\n  event LogUintStringString(uint a, string b, string c);\n\n  function log(\n    uint a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogUintStringString(a, b, c);\n  }\n\n  /* End of register/read section */\n  event ERC20Balances(address[] tokens, address[] accounts, uint[] balances);\n\n  function logBalances(\n    address[1] memory _tokens, \n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  /* takes [t1,...,tM], [a1,...,aN]\n       logs also [...b(t1,aj) ... b(tM,aj) ...] */\n\n  function logBalances(address[] memory tokens, address[] memory accounts)\n    internal\n  {\n    uint[] memory balances = new uint[](tokens.length * accounts.length);\n    for (uint i = 0; i < tokens.length; i++) {\n      for (uint j = 0; j < accounts.length; j++) {\n        uint bal = ERC20BalanceOf(tokens[i]).balanceOf(accounts[j]);\n        balances[i * accounts.length + j] = bal;\n        //console.log(tokens[i].symbol(),nameOf(accounts[j]),bal);\n      }\n    }\n    emit ERC20Balances(tokens, accounts, balances);\n  }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}