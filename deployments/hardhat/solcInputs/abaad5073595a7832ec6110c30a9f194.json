{
  "language": "Solidity",
  "sources": {
    "contracts/tests/xBitsToken_Test.sol": {
      "content": "// Adds Test library to the context\nimport \"@mangrovedao/hardhat-test-solidity/test.sol\";\nimport \"../xBitsToken.sol\";\n\npragma solidity ^0.8.6;\n\n// `_Test` suffix means it is a test contract\ncontract xBitsToken_Test is xBitsToken(address(0)) {\n\n  function initialize() internal override{\n\n    Test.eq(totalSupply, 21000000 * 10**uint(decimals),\"Incorrect total supply\");\n    \n    maxSupplyForEra = totalSupply - (totalSupply / ( 2**(rewardEra + 1)));\n\n    Test.eq(maxSupplyForEra, 10500000 * 10**uint(decimals),\"Incorrect total supply\");\n\n  }\n \n  // `_test` suffix means it is a test function\n  function mining_epoch_test() public {\n\n\n    //rewardEra = 1; \n   // super._startNewMiningEpoch();\n\n\n    //Test.eq(4,2+2,\"oh no\");\n  }\n\n  \n}"
    },
    "@mangrovedao/hardhat-test-solidity/test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\n// Should be kept in sync with ./lib.js\n\nlibrary Test {\n  /* \n   * Expect events from contracts\n   */\n  event ExpectFrom(address from);\n  event StopExpecting();\n\n  // Usage: from a test contract `t`, call `expectFrom(a)`. \n  // Any subsequent non-special event emitted by `t` will mean \n  // \"I expect `a` to emit the exact same event\". \n  // The order of expectations must be respected.\n  function expectFrom(address from) internal {\n    emit ExpectFrom(from);\n  }\n\n  // After using `expectFrom` and emitting some events you expect\n  // to see emitted elsewhere, you can use `stopExpecting` to emit \n  // further, normal events from your test.\n  function stopExpecting() internal {\n    emit StopExpecting();\n  }\n\n\n  /* \n   * Boolean test\n   */\n  event TestTrue(bool success, string message);\n\n  // Succeed iff success is true\n  function check(bool success, string memory message) internal {\n    emit TestTrue(success, message);\n  }\n\n\n  /* \n   * Always fail, always succeed\n   */\n  function fail(string memory message) internal {\n    emit TestTrue(false, message);\n  }\n\n  function succeed() internal {\n    emit TestTrue(true, \"Success\");\n  }\n\n  /* \n   * Equality testing\n   * ! overloaded as `eq` for everything except for bytes use `eq0`.\n   */\n\n  // Bytes\n  event TestEqBytes(bool success, bytes actual, bytes expected, string message);\n\n  function eq0(\n    bytes memory actual,\n    bytes memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256((actual)) == keccak256((expected));\n    emit TestEqBytes(success, actual, expected, message);\n    return success;\n  }\n\n   // Byte32\n  event TestEqBytes32(\n    bool success,\n    bytes32 actual,\n    bytes32 expected,\n    string message\n  );\n\n  function eq(\n    bytes32 actual,\n    bytes32 expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBytes32(success, actual, expected, message);\n    return success;\n  }\n\n  // Bool\n  event TestEqBool(bool success, bool actual, bool expected, string message);\n  function eq(\n    bool actual,\n    bool expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = (actual == expected);\n    emit TestEqBool(success, actual, expected, message);\n    return success;\n  }\n\n  // uints\n  event TestEqUint(bool success, uint actual, uint expected, string message);\n\n  function eq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqUint(success, actual, expected, message);\n    return success;\n  }\n\n  // strings\n  event TestEqString(\n    bool success,\n    string actual,\n    string expected,\n    string message\n  );\n\n  function eq(\n    string memory actual,\n    string memory expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = keccak256(bytes((actual))) == keccak256(bytes((expected)));\n    emit TestEqString(success, actual, expected, message);\n    return success;\n  }\n\n  // addresses\n  event TestEqAddress(\n    bool success,\n    address actual,\n    address expected,\n    string message\n  );\n\n\n  function eq(\n    address actual,\n    address expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual == expected;\n    emit TestEqAddress(success, actual, expected, message);\n    return success;\n  }\n\n  /* \n   * Inequality testing\n   */\n  event TestLess(bool success, uint actual, uint expected, string message);\n  function less(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual < expected;\n    emit TestLess(success, actual, expected, message);\n    return success;\n  }\n\n  event TestLessEq(bool success, uint actual, uint expected, string message);\n  function lessEq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual <= expected;\n    emit TestLessEq(success, actual, expected, message);\n    return success;\n  }\n\n  event TestMore(bool success, uint actual, uint expected, string message);\n  function more(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual > expected;\n    emit TestMore(success, actual, expected, message);\n    return success;\n  }\n\n  event TestMoreEq(bool success, uint actual, uint expected, string message);\n  function moreEq(\n    uint actual,\n    uint expected,\n    string memory message\n  ) internal returns (bool) {\n    bool success = actual >= expected;\n    emit TestMoreEq(success, actual, expected, message);\n    return success;\n  }\n}\n\n// /* Either cast your arguments to address when you call balanceOf logging functions\n//    or add `is address` to your ERC20s\n//    or use the overloads with `address` types */\ninterface ERC20BalanceOf {\n  function balanceOf(address account) view external returns (uint);\n}\n\n\nlibrary Display {\n  /* ****************************************************************\n   * Register/read address->name mappings to make logs easier to read.\n   *****************************************************************/\n  /* \n   * Names are stored in the contract using the library.\n   */\n\n  // Disgusting hack so a library can manipulate storage refs.\n  bytes32 constant NAMES_POS = keccak256(\"Display.NAMES_POS\");\n  // Store mapping in library caller's storage.\n  // That's quite fragile.\n  struct Registers {\n    mapping(address => string) map;\n  }\n\n  // Also send mapping to javascript test interpreter.  The interpreter COULD\n  // just make an EVM call to map every name but that would probably be very\n  // slow.  So we cache locally.\n  event Register(address addr, string name);\n\n  function registers() internal view returns (Registers storage) {\n    this; // silence warning about pure mutability\n    Registers storage regs;\n    bytes32 _slot = NAMES_POS;\n    assembly {\n      regs.slot := _slot\n    }\n    return regs;\n  }\n\n  /*\n   * Give a name to an address for logging purposes\n   * @example\n   * ```solidity\n   * address addr = address(new Contract());\n   * register(addr,\"My Contract instance\");\n   * ```\n   */\n\n  function register(address addr, string memory name) internal {\n    registers().map[addr] = name;\n    emit Register(addr, name);\n  }\n\n  /*\n   * Read the name of a registered address. Default: \"<not found>\". \n   */\n  function nameOf(address addr) internal view returns (string memory) {\n    string memory s = registers().map[addr];\n    if (keccak256(bytes(s)) != keccak256(bytes(\"\"))) {\n      return s;\n    } else {\n      return \"<not found>\";\n    }\n  }\n\n  /* 1 arg logging (string/uint) */\n\n  event LogString(string a);\n\n  function log(string memory a) internal {\n    emit LogString(a);\n  }\n\n  event LogUint(uint a);\n\n  function log(uint a) internal {\n    emit LogUint(a);\n  }\n\n  /* 2 arg logging (string/uint) */\n\n  event LogStringString(string a, string b);\n\n  function log(string memory a, string memory b) internal {\n    emit LogStringString(a, b);\n  }\n\n  event LogStringUint(string a, uint b);\n\n  function log(string memory a, uint b) internal {\n    emit LogStringUint(a, b);\n  }\n\n  event LogUintUint(uint a, uint b);\n\n  function log(uint a, uint b) internal {\n    emit LogUintUint(a, b);\n  }\n\n  event LogUintString(uint a, string b);\n\n  function log(uint a, string memory b) internal {\n    emit LogUintString(a, b);\n  }\n\n  /* 3 arg logging (string/uint) */\n\n  event LogStringStringString(string a, string b, string c);\n\n  function log(\n    string memory a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogStringStringString(a, b, c);\n  }\n\n  event LogStringStringUint(string a, string b, uint c);\n\n  function log(\n    string memory a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogStringStringUint(a, b, c);\n  }\n\n  event LogStringUintUint(string a, uint b, uint c);\n\n  function log(\n    string memory a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogStringUintUint(a, b, c);\n  }\n\n  event LogStringUintString(string a, uint b, string c);\n\n  function log(\n    string memory a,\n    uint b,\n    string memory c\n  ) internal {\n    emit LogStringUintString(a, b, c);\n  }\n\n  event LogUintUintUint(uint a, uint b, uint c);\n\n  function log(\n    uint a,\n    uint b,\n    uint c\n  ) internal {\n    emit LogUintUintUint(a, b, c);\n  }\n\n  event LogUintStringUint(uint a, string b, uint c);\n\n  function log(\n    uint a,\n    string memory b,\n    uint c\n  ) internal {\n    emit LogUintStringUint(a, b, c);\n  }\n\n  event LogUintStringString(uint a, string b, string c);\n\n  function log(\n    uint a,\n    string memory b,\n    string memory c\n  ) internal {\n    emit LogUintStringString(a, b, c);\n  }\n\n  /* End of register/read section */\n  event ERC20Balances(address[] tokens, address[] accounts, uint[] balances);\n\n  function logBalances(\n    address[1] memory _tokens, \n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[1] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](1);\n    tokens[0] = _tokens[0];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](1);\n    accounts[0] = _a0;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](2);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    logBalances(tokens, accounts);\n  }\n\n  function logBalances(\n    address[2] memory _tokens,\n    address _a0,\n    address _a1,\n    address _a2\n  ) internal {\n    address[] memory tokens = new address[](2);\n    tokens[0] = _tokens[0];\n    tokens[1] = _tokens[1];\n    address[] memory accounts = new address[](3);\n    accounts[0] = _a0;\n    accounts[1] = _a1;\n    accounts[2] = _a2;\n    logBalances(tokens, accounts);\n  }\n\n  /* takes [t1,...,tM], [a1,...,aN]\n       logs also [...b(t1,aj) ... b(tM,aj) ...] */\n\n  function logBalances(address[] memory tokens, address[] memory accounts)\n    internal\n  {\n    uint[] memory balances = new uint[](tokens.length * accounts.length);\n    for (uint i = 0; i < tokens.length; i++) {\n      for (uint j = 0; j < accounts.length; j++) {\n        uint bal = ERC20BalanceOf(tokens[i]).balanceOf(accounts[j]);\n        balances[i * accounts.length + j] = bal;\n        //console.log(tokens[i].symbol(),nameOf(accounts[j]),bal);\n      }\n    }\n    emit ERC20Balances(tokens, accounts, balances);\n  }\n\n}"
    },
    "contracts/xBitsToken.sol": {
      "content": "pragma solidity ^0.8.6;\n\n\n// ----------------------------------------------------------------------------\n\n// '0xBitcoin Token' contract  \n\n// Mineable ERC20 Token using Proof Of Work\n\n//\n\n// Symbol      : 0xBTC\n\n// Name        : 0xBitcoin Token\n\n// Total supply: 21,000,000.00\n\n// Decimals    : 8\n\n// Version     : 2\n\n//\n\n\n// ----------------------------------------------------------------------------\n\n\n\n\n\n\n// ----------------------------------------------------------------------------\n\n// ERC Token Standard #20 Interface\n\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n\n// ----------------------------------------------------------------------------\n\nabstract contract ERC20Interface {\n\n    function totalSupply() external virtual view returns (uint);\n\n    function balanceOf(address tokenOwner) external virtual view returns (uint balance);\n\n    function allowance(address tokenOwner, address spender) external virtual view returns (uint remaining);\n\n    function transfer(address to, uint tokens) external virtual returns (bool success);\n\n    function approve(address spender, uint tokens) external virtual returns (bool success);\n\n    function transferFrom(address from, address to, uint tokens) external virtual returns (bool success);\n\n    function _approve(address owner, address spender, uint tokens) internal virtual returns (bool success);\n\n    function _transfer(address from, address to, uint tokens) internal virtual returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n\n}\n\ncontract ERC20Standard is ERC20Interface {\n \n    string public symbol;\n    string public name;\n\n    uint8 public decimals;\n\n    mapping(address => uint) balances;   \n    mapping(address => mapping(address => uint)) allowed;\n \n    uint public override totalSupply; \n\n\n\n    function _transfer(address from, address to, uint tokens) internal override returns (bool success) {\n\n        balances[from] = balances[from] - (tokens);\n\n        balances[to] = balances[to] + (tokens);\n\n        emit Transfer(from, to, tokens);\n\n        return true;\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Get the token balance for account `tokenOwner`\n\n    // ------------------------------------------------------------------------\n\n    function balanceOf(address tokenOwner) public override view returns (uint balance) {\n\n        return balances[tokenOwner];\n\n    }\n\n\n\n    // ------------------------------------------------------------------------\n\n    // Transfer the balance from token owner's account to `to` account\n\n    // - Owner's account must have sufficient balance to transfer\n\n    // - 0 value transfers are allowed\n\n    // ------------------------------------------------------------------------\n\n    function transfer(address to, uint tokens) public override returns (bool success) {\n\n        return _transfer(msg.sender, to, tokens);\n\n    }\n\n  \n\n\n    // ------------------------------------------------------------------------\n\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n\n    // from the token owner's account\n\n    //\n\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n\n    // recommends that there are no checks for the approval double-spend attack\n\n    // as this should be implemented in user interfaces\n\n    // ------------------------------------------------------------------------\n\n    function approve(address spender, uint tokens) public override returns (bool success) {\n\n        return _approve(msg.sender, spender,tokens);\n\n    }\n\n    function _approve(address owner, address spender, uint tokens) internal override returns (bool success) {\n\n        allowed[owner][spender] = tokens;\n\n        emit Approval(owner, spender, tokens);\n\n        return true;\n\n    } \n\n\n    // ------------------------------------------------------------------------\n\n    // Transfer `tokens` from the `from` account to the `to` account\n\n    //\n\n    // The calling account must already have sufficient tokens approve(...)-d\n\n    // for spending from the `from` account and\n\n    // - From account must have sufficient balance to transfer\n\n    // - Spender must have sufficient allowance to transfer\n\n    // - 0 value transfers are allowed\n\n    // ------------------------------------------------------------------------\n\n    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n        \n        allowed[from][msg.sender] = allowed[from][msg.sender] - (tokens);\n\n        return _transfer(from,to,tokens);\n\n    }\n\n\n    // ------------------------------------------------------------------------\n\n    // Returns the amount of tokens approved by the owner that can be\n\n    // transferred to the spender's account\n\n    // ------------------------------------------------------------------------\n\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n\n        return allowed[tokenOwner][spender];\n\n    }\n\n\n}\n\n\n\n\nabstract contract EIP918Interface {\n\n  function challengeNumber() virtual external returns (bytes32);\n  function tokensMinted() virtual external returns (uint256);\n  function miningTarget() virtual external returns (uint256);\n  function maxSupplyForEra() virtual external returns (uint256);  \n  function latestDifficultyPeriodStarted() virtual external returns (uint256);\n  function rewardEra() virtual external returns (uint256);\n  function epochCount() virtual external returns (uint256); \n  function getMiningReward() virtual external returns (uint256);\n\n}\n\n\nlibrary ECRecover {\n    /**\n     * @notice Recover signer's address from a signed message\n     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol\n     * Modifications: Accept v, r, and s as separate arguments\n     * @param digest    Keccak-256 hash digest of the signed message\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     * @return Signer address\n     */\n    function recover(\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            revert(\"ECRecover: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECRecover: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), \"ECRecover: invalid signature\");\n\n        return signer;\n    }\n}\n\n\n\ncontract EIP712Domain {\n    /**\n     * @dev EIP712 Domain Separator\n     */\n    bytes32 public DOMAIN_SEPARATOR;\n}\n\n\n\n/**\n * @title EIP712\n * @notice A library that provides EIP712 helper functions\n */\nlibrary EIP712 {\n    /**\n     * @notice Make EIP712 domain separator\n     * @param name      Contract name\n     * @param version   Contract version\n     * @return Domain separator\n     */\n    function makeDomainSeparator(string memory name, string memory version)\n        internal\n        view\n        returns (bytes32)\n    {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return\n            keccak256(\n                abi.encode(\n                    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    keccak256(bytes(name)),\n                    keccak256(bytes(version)),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @notice Recover signer's address from a EIP712 signature\n     * @param domainSeparator   Domain separator\n     * @param v                 v of the signature\n     * @param r                 r of the signature\n     * @param s                 s of the signature\n     * @param typeHashAndData   Type hash concatenated with data\n     * @return Signer's address\n     */\n    function recover(\n        bytes32 domainSeparator,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes memory typeHashAndData\n    ) internal pure returns (address) {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(typeHashAndData)\n            )\n        );\n        return ECRecover.recover(digest, v, r, s);\n    }\n \n}\n\n\n/**\n * @title EIP-2612\n * @notice Provide internal implementation for gas-abstracted approvals\n */\ncontract EIP2612 is EIP712Domain,ERC20Standard {\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    bytes32\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint256) private _permitNonces;\n\n    /**\n     * @notice Nonces for permit\n     * @param owner Token owner's address (Authorizer)\n     * @return Next nonce\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return _permitNonces[owner];\n    }\n\n    /**\n     * @notice Verify a signed approval permit and execute if valid\n     * @param owner     Token owner's address (Authorizer)\n     * @param spender   Spender's address\n     * @param value     Amount of allowance\n     * @param deadline  The time at which this expires (unix time)\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        require(deadline >= block.timestamp, \"Permit is expired\");\n\n        bytes memory data = abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            _permitNonces[owner]++,\n            deadline\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"EIP2612: invalid signature\"\n        );\n\n        _approve(owner, spender, value);\n    }\n\n \n}\n\n\n\n\n\nlibrary ExtendedMath {\n\n\n    //return the smaller of the two inputs (a or b)\n    function limitLessThan(uint a, uint b) internal pure returns (uint c) {\n\n        if(a > b) return b;\n\n        return a;\n\n    }\n}\n\n\n\ncontract xBitsToken is ERC20Standard, EIP2612 {\n   \n    using ExtendedMath for uint;\n   \n    string public version;    \n\n    uint public latestDifficultyPeriodStarted;\n\n    uint public epochCount; \n\n    uint public _BLOCKS_PER_READJUSTMENT = 1024;   \n    uint public  _MINIMUM_TARGET = 2**16;      \n    uint public  _MAXIMUM_TARGET = 2**234;\n\n\n    uint public miningTarget;\n    bytes32 public challengeNumber;  \n\n    uint public rewardEra;\n    uint public maxSupplyForEra;\n\n    uint public currentMiningReward;\n    address public lastRewardTo;\n    uint public lastRewardAmount;\n    uint public lastRewardEthBlockNumber; \n\n    uint public tokensMinted;\n\n    address public originalTokenContract; \n\n    uint256 public amountDeposited;\n\n    event Mint(address from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n    \n\n    constructor( address _originalTokenContract ) {\n\n        originalTokenContract = _originalTokenContract;\n\n        symbol = \"xBit\";\n\n        name = \"xBits Token\";\n\n        decimals = 8;\n\n        version = \"2\";\n\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(name, version);\n\n        totalSupply = 21000000 * 10**uint(decimals); \n\n        initialize(); \n\n    }\n\n    //set values to continue state forwards where it left off \n    function initialize() internal virtual {\n \n      epochCount = EIP918Interface( originalTokenContract  ).epochCount();\n      \n      tokensMinted = EIP918Interface( originalTokenContract  ).tokensMinted();\n\n      rewardEra = EIP918Interface(originalTokenContract).rewardEra();\n      maxSupplyForEra = EIP918Interface(originalTokenContract).maxSupplyForEra();\n\n      miningTarget = EIP918Interface(originalTokenContract).miningTarget();\n\n      latestDifficultyPeriodStarted = EIP918Interface(originalTokenContract).latestDifficultyPeriodStarted();   \n      challengeNumber = EIP918Interface(originalTokenContract).challengeNumber();\n        \n      currentMiningReward = EIP918Interface(originalTokenContract).getMiningReward();\n\n    }\n\n\n    function mint(uint256 nonce, bytes32) public returns (bool success) {\n\n        return mintTo(nonce,msg.sender);\n\n    }\n\n    function mintTo(uint256 nonce, address minter) public returns (bool success) {\n    \n        //the PoW must contain work that includes a recent ethereum block hash (challenge number) and the msg.sender's address to prevent MITM attacks\n        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, minter, nonce ));\n\n        //the digest must be smaller than the target\n        if(uint256(digest) > miningTarget) revert();\n\n        //only allow one reward for each block\n        require(lastRewardEthBlockNumber != block.number);\n      \n        uint reward_amount = currentMiningReward;\n\n        balances[minter] = balances[minter] + (reward_amount);\n        emit Transfer(address(this), minter, reward_amount);\n\n        tokensMinted = tokensMinted + (reward_amount);\n\n        //Cannot mint more tokens than there are\n        require(tokensMinted <= maxSupplyForEra);\n\n        //set readonly diagnostics data\n        lastRewardTo = minter;\n        lastRewardAmount = reward_amount;\n        lastRewardEthBlockNumber = block.number;\n\n        _startNewMiningEpoch();\n\n        emit Mint(minter, reward_amount, epochCount, challengeNumber );        \n\n        return true;\n\n    }\n\n\n    \n    function _startNewMiningEpoch() internal {\n\n      //if max supply for the era will be exceeded next reward round then enter the new era before that happens\n\n      //32 is the final reward era, almost all tokens minted\n      //once the final era is reached, more tokens will not be given out because the assert function\n      if(tokensMinted + (currentMiningReward) > maxSupplyForEra && rewardEra < 31)\n      {\n        rewardEra = rewardEra + 1;\n        currentMiningReward = (50 * 10**uint(decimals) ) / ( 2**rewardEra ) ;\n      }\n\n      //set the next minted supply at which the era will change\n      //total supply is 2100000000000000  because of 8 decimal places\n      maxSupplyForEra = totalSupply - (totalSupply / ( 2**(rewardEra + 1)));\n\n      epochCount = epochCount + 1;\n\n      //every so often, readjust difficulty. Dont readjust when deploying\n      if(epochCount % _BLOCKS_PER_READJUSTMENT == 0)\n      {\n      _reAdjustDifficulty();\n      }\n\n\n      //make the latest ethereum block hash a part of the next challenge for PoW to prevent pre-mining future blocks\n     challengeNumber = blockhash(block.number - 1);      \n\n    }\n\n\n \n    function _reAdjustDifficulty() internal {\n\n        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n\n        uint epochsMined = _BLOCKS_PER_READJUSTMENT; \n\n        uint targetEthBlocksPerDiffPeriod = epochsMined * 60; \n\n        //if there were less eth blocks passed in time than expected\n        if( ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod )\n        {\n          uint excess_block_pct = (targetEthBlocksPerDiffPeriod * (100)) / ( ethBlocksSinceLastDifficultyPeriod );\n\n          uint excess_block_pct_extra = (excess_block_pct - 100).limitLessThan(1000);\n          // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\n\n          //make it harder\n          miningTarget = miningTarget - ((miningTarget / 2000) * excess_block_pct_extra);   //by up to 50 %\n        }else{\n          uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod * (100)) / ( targetEthBlocksPerDiffPeriod );\n\n          uint shortage_block_pct_extra = (shortage_block_pct - 100).limitLessThan(1000); //always between 0 and 1000\n\n          //make it easier\n          miningTarget = miningTarget + ((miningTarget / 2000) * shortage_block_pct_extra);   //by up to 50 %\n        }\n\n\n        latestDifficultyPeriodStarted = block.number;\n\n        if(miningTarget < _MINIMUM_TARGET) //most difficult\n        {\n          miningTarget = _MINIMUM_TARGET;\n        }\n\n        if(miningTarget > _MAXIMUM_TARGET) //most easy\n        {\n          miningTarget = _MAXIMUM_TARGET;\n        }\n    }\n\n\n    //this is a recent ethereum block hash, used to prevent pre-mining future blocks\n    function getChallengeNumber() public view returns (bytes32) {\n        return challengeNumber;\n    }\n\n    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts\n     function getMiningDifficulty() public view returns (uint) {\n        return _MAXIMUM_TARGET / (miningTarget);\n    }\n\n    function getMiningTarget() public view returns (uint) {\n       return miningTarget;\n    }\n\n\n     /**\n     * @dev Burn v1 tokens to receive v2 tokens\n     * @param amount Amount of original tokens to change\n     */\n    function deposit(address from, uint amount) internal returns (bool)\n    {         \n        require( ERC20Interface( originalTokenContract ).transferFrom( from, address(this), amount) );\n        \n        balances[from] = balances[from] + (amount);\n        amountDeposited = amountDeposited + (amount);\n        \n        emit Transfer(address(this), from, amount);\n        \n        return true;\n    }\n\n\n    function minedSupply() public view returns (uint) {\n\n        return tokensMinted;\n\n    }\n   \n      /**\n     * @notice Update allowance with a signed permit\n     * @param owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        _permit(owner, spender, value, deadline, v, r, s);\n    }\n\n      \n    function receiveApproval(address from, uint256 tokens, address token, bytes memory) public returns (bool success) {\n        \n        require( token == originalTokenContract );\n        \n        require( deposit(from, tokens) );\n\n        return true;\n\n     }\n\n\n    // ------------------------------------------------------------------------\n\n    // Don't accept ETH\n\n    // ------------------------------------------------------------------------\n\n    receive() external payable {\n\n        revert();\n\n    }\n\n \n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}