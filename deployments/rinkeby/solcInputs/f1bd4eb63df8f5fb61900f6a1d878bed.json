{
  "language": "Solidity",
  "sources": {
    "contracts/FixedSupplyToken.sol": {
      "content": " \n\npragma solidity ^0.8.0;\n\n// ----------------------------------------------------------------------------------------------\n// Sample fixed supply token contract\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\n// ----------------------------------------------------------------------------------------------\n\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/issues/20\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n \ncontract FixedSupplyToken is IERC20 {\n    string public constant symbol = \"FIXED\";\n    string public constant name = \"Example Fixed Supply Token\";\n    uint8 public constant decimals = 8;\n    uint256 _totalSupply = 21000000 * 10**uint(decimals);\n\n\n\n    // Owner of this contract\n    address public owner;\n\n    // Balances for each account\n    mapping(address => uint256) public balances;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping (address => uint256)) public allowed;\n\n    // Functions with this modifier can only be executed by the owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Constructor\n    constructor() public {\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n    }\n\n\n    function mint(address to, uint256 amount) public {\n         balances[to] += amount;\n    }\n\n    function totalSupply() public view override returns (uint256 totalSupply) {\n        totalSupply = _totalSupply;\n    }\n\n    // What is the balance of a particular account?\n    function balanceOf(address _owner) public view override returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    // Transfer the balance from owner's account to another account\n    function transfer(address _to, uint256 _amount) public override returns (bool success) {\n        if (balances[msg.sender] >= _amount\n            && _amount > 0\n            && balances[_to] + _amount > balances[_to]) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            emit Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Send _value amount of tokens from address _from to address _to\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n    // fees in sub-currencies; the command should fail unless the _from account has\n    // deliberately authorized the sender of the message via some mechanism; we propose\n    // these standardized APIs for approval:\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public override returns (bool success) {\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0\n            && balances[_to] + _amount > balances[_to]) {\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            balances[_to] += _amount;\n            emit Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    // If this function is called again it overwrites the current allowance with _value.\n    function approve(address _spender, uint256 _amount) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/Payspec.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/*\nPAYSPEC: Atomic and deterministic invoicing system\n\nGenerate offchain invoices based on sell-order data and allow users to fulfill those order invoices onchain.\n\n*/\n \n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n\n\n  \ncontract Payspec is Ownable, ReentrancyGuard {\n\n  uint256 public immutable contractVersion  = 100;\n  address immutable ETHER_ADDRESS = address(0x0000000000000000000000000000000000000010);\n  \n  mapping(bytes32 => Invoice) public invoices; \n\n  bool lockedByOwner = false; \n\n  event CreatedInvoice(bytes32 uuid); \n  event PaidInvoice(bytes32 uuid, address from);\n\n\n  struct Invoice {\n    bytes32 uuid;\n    string description;\n    uint256 nonce;\n    bool created;\n\n\n    address token;\n    uint256 amountDue;\n    address payTo;\n\n    address[] feeAddresses;\n    uint[] feePercents;\n\n    address paidBy;\n    uint256 amountPaid;\n    uint256 ethBlockPaidAt;\n\n\n    uint256 ethBlockExpiresAt;\n\n  }\n\n\n\n  constructor(   ) public {\n\n  } \n \n\n  function lockContract() public onlyOwner {\n    lockedByOwner = true;\n  }\n\n\n   \n\n\n  function createAndPayInvoice(  string memory description, uint256 nonce, address token, uint256 amountDue, address payTo, address[] memory feeAddresses, uint[] memory feePercents, uint256 ethBlockExpiresAt, bytes32 expecteduuid  ) \n    public \n    payable \n    nonReentrant\n    returns (bool) {\n     \n     if(token == ETHER_ADDRESS){\n       require(msg.value == amountDue, \"Transaction sent incorrect ETH amount.\");\n     }else{\n       require(msg.value == 0, \"Transaction sent ETH for an ERC20 invoice.\");\n     }\n     \n     bytes32 newuuid = _createInvoice(description,nonce,token,amountDue,payTo,feeAddresses, feePercents,ethBlockExpiresAt,expecteduuid);\n     require(newuuid == expecteduuid);\n     return _payInvoice(newuuid);\n  }\n\n   function _createInvoice(  string memory description, uint256 nonce, address token, uint256 amountDue, address payTo, address[] memory feeAddresses, uint[] memory feePercents, uint256 ethBlockExpiresAt, bytes32 expecteduuid ) \n    private \n    returns (bytes32 uuid) { \n\n\n      bytes32 newuuid = getInvoiceUUID(description, nonce, token, amountDue, payTo, feeAddresses, feePercents,  ethBlockExpiresAt ) ;\n\n      require(!lockedByOwner);\n      require( newuuid == expecteduuid );\n      require( invoices[newuuid].uuid == 0 );  //make sure you do not overwrite invoices\n      require(feeAddresses.length == feePercents.length);\n\n      require(ethBlockExpiresAt == 0 || block.number < ethBlockExpiresAt);\n\n      invoices[newuuid] = Invoice({\n       uuid:newuuid,\n       description:description,\n       nonce: nonce,\n       token: token,\n       amountDue: amountDue,\n       payTo: payTo,\n       paidBy: address(0),\n       feeAddresses: feeAddresses,\n       feePercents: feePercents,\n       amountPaid: 0,\n       ethBlockPaidAt: 0,\n       ethBlockExpiresAt: ethBlockExpiresAt,\n       created:true\n      });\n\n\n       emit CreatedInvoice(newuuid);\n\n       return newuuid;\n   }\n\n   function _payInvoice( bytes32 invoiceUUID ) private returns (bool) {\n\n       address from = msg.sender;\n\n       require(!lockedByOwner);\n       require( invoices[invoiceUUID].uuid == invoiceUUID ); //make sure invoice exists\n       require( invoiceWasPaid(invoiceUUID) == false ); \n\n       uint totalAmountDueInFees = 0; // invoices[invoiceUUID].amountDue.mul( fee_pct ).div(100);\n\n\n\n       for(uint i=0;i<invoices[invoiceUUID].feeAddresses.length;i++){\n              uint amtDueInFees =  invoices[invoiceUUID].amountDue * ( invoices[invoiceUUID].feePercents[i] / 100);\n\n              //transfer each fee to fee recipient\n              require(  _payTokenAmount(invoices[invoiceUUID].token , from , invoices[invoiceUUID].feeAddresses[i], amtDueInFees ) , \"Unable to pay fees amount due.\" );\n\n              totalAmountDueInFees = totalAmountDueInFees + amtDueInFees ;\n       }\n \n\n      uint amountDueLessFees =  invoices[invoiceUUID].amountDue - totalAmountDueInFees ; \n\n      //transfer the tokens to the seller\n      require( _payTokenAmount(  invoices[invoiceUUID].token ,  from,  invoices[invoiceUUID].payTo, amountDueLessFees  ),\"Unable to pay amount due.\");\n\n      //mark the invoice as paid \n       invoices[invoiceUUID].amountPaid = invoices[invoiceUUID].amountDue;\n\n       invoices[invoiceUUID].paidBy = from;\n\n       invoices[invoiceUUID].ethBlockPaidAt = block.number;\n\n\n\n       emit PaidInvoice(invoiceUUID, from);\n\n       return true;\n\n\n   }\n\n\n   function _payTokenAmount(address tokenAddress, address from, address to, uint256 tokenAmount) \n      internal \n      returns (bool) {\n      \n      if(tokenAddress == ETHER_ADDRESS){\n        payable(to).transfer( tokenAmount ); \n      }else{ \n        IERC20( tokenAddress  ).transferFrom( from ,  to, tokenAmount  );\n      }\n      return true;\n   }\n\n\n\n   function getInvoiceUUID(  string memory description, uint256 nonce, address token, uint256 amountDue, address payTo, address[] memory feeAddresses, uint[] memory feePercents, uint expiresAt  ) public view returns (bytes32 uuid) {\n\n         address payspecContractAddress = address(this); //prevent from paying through the wrong contract\n\n         bytes32 newuuid = keccak256( abi.encodePacked(payspecContractAddress, description, nonce, token, amountDue, payTo, feeAddresses, feePercents, expiresAt ) );\n\n         return newuuid;\n    }\n\n   function invoiceWasPaid( bytes32 invoiceUUID ) public view returns (bool){\n\n       return invoices[invoiceUUID].amountPaid >= invoices[invoiceUUID].amountDue;\n   }\n\n   function invoiceWasCreated( bytes32 invoiceUUID ) public view returns (bool){\n\n       return invoices[invoiceUUID].created ;\n   }\n\n\n\n    function getInvoiceDescription( bytes32 invoiceUUID ) public view returns (string memory){\n\n       return invoices[invoiceUUID].description;\n   }\n\n   function getInvoiceTokenCurrency( bytes32 invoiceUUID ) public view returns (address){\n\n       return invoices[invoiceUUID].token;\n   }\n\n\n   function getInvoiceAmountPaid( bytes32 invoiceUUID ) public view returns (uint){\n\n       return invoices[invoiceUUID].amountPaid;\n   }\n\n   function getInvoicePayer( bytes32 invoiceUUID ) public view returns (address){\n\n       return invoices[invoiceUUID].paidBy;\n   }\n\n   function getInvoiceEthBlockPaidAt( bytes32 invoiceUUID ) public view returns (uint){\n\n       return invoices[invoiceUUID].ethBlockPaidAt;\n   }\n\n \n\n\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}